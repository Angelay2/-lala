/*
1. 最难的问题 
NowCoder生活在充满危险和阴谋的年代。为了生存，他首次发明了密码，用于军队的消息传递。假设你是军团中的一名军官，需要把发送来的消息破译出来、并提供给你的将军。 消息加密的办法是：对消息原文中的每个字母，分别用该字母之后的第5个字母替换（例如：消息原文中的每个字母A都分别替换成字母F），其他字符不 变，并且消息原文的所有字母都是大写的。密码中的字母与原文中的字母对应关系如下。 
密码字母：A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 
原文字母：V W X Y Z A B C D E F G H I J K L M N O P Q R S T U 

输入描述： 输入包括多组数据，每组数据一行，为收到的密文。 密文仅有空格和大写字母组成。 
输出描述： 对应每一组数据，输出解密后的明文。

【题目解析】：
题目很容易理解，原文与密码错位5个英文字符
密码字母：A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 
原文字母：V W X Y Z A B C D E F G H I J K L M N O P Q R S T U
【解题思路】：
密码 > 'E'
则：原文 = 密码 - 5
否则： 原文 = 密码 + 21
*/
#include <stdio.h> 
int main() { 
	char c; 
	while ((c = getchar()) != EOF){
		if ('A' <= c && 'Z' >= c) {
			c = (c > 'E') ? (c - 5) : (c + 21);
		}
		putchar(c);
	}
	return 0; 
}

/*
2. 因子个数
一个正整数可以分解成一个或多个数组的积。例如36=2*2*3*3，即包含2和3两个因子。NowCoder最近在研究因子个数的分布规律，现在给出一系列正整数，他希望你开发一个程序输出每个正整数的因子个数。 

输入描述： 输入包括多组数据。 每组数据仅有一个整数n (2≤n≤100000)。 
输出描述：对应每个整数，输出其因子个数，每个结果占一行。

【题目解析】：求一个数字的因子（>=2的最小不能整除数字）个数
【解题思路】：
从最小因子2到数字的最大因子数（数字的平方根）开始判断是否能够取余
可以则循环取余直到取余不为0，因子个数+1；
否则使用下一个因子计算；
最终整除了各个因子数之后剩余的数字不为1 则本身也是一个因子，因此因子数+1
*/

#include <iostream> 
#include<math.h> 
using namespace std; 

int main() {
	int n, k, i;
	while(cin >> n){ 
		k = 0;
		for(i = 2; i <= sqrt(n); i++) {
			if ((n % i) == 0) { // 可以整除
				while((n % i) == 0){
					n = n / i;// 商
				}
				k++; // 有一个因子了
			}
		}
		if (n != 1)// 商 等于1则是本身除以本身得到的结果
			k++;// 因子加1
		cout << k << endl;
	}
	return 0; 
}